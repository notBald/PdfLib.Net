/**
 * Original version by Marco Schmidt.
 * 
 * Rewritten for C#
 * 
 * This class is contributed to the Public Domain.
 * Use it at your own risk.
 */

#region History

/**
 * History:
 * 
 * 2001-08-24 Initial version.
 * 2001-10-13 Added support for the File formats BMP and PCX.
 * 2001-10-16 Fixed bug in read(int[], int, int) that returned
 * 2002-01-22 Added support for File formats Amiga IFF and Sun Raster (RAS).
 * 2002-01-24 Added support for File formats Portable Bitmap / Graymap / Pixmap (PBM, PGM, PPM) 
 *  and Adobe Photoshop (PSD).
 *  Added new method getMimeType() to return the MIME type associated with a particular File 
 *  format.
 * 2002-03-15 Added support to recognize number of images in File. Only works with GIF.
 *  Set setDetermineImageNumber(bool)" true as argument to identify animated GIFs
 *  getNumberOfImages() will return a value larger than 1.
 * 2002-04-10 Fixed a bug in the feature 'determine number of images in animated GIF' 
 *  introduced with version 1.1. Thanks to Marcelo P. Lima for sending in the bug report. 
 *  Released as 1.1.1.</li>
 * 2002-04-18 Added setCollectComments(boolean) 
 *  That new method lets the user specify whether textual comments are to be stored in an 
 *  internal list when encountered in an input image File / stream.
 *  Added two methods to return the physical width and height of the image in dpi: 
 *  getPhysicalWidthDpi() and getPhysicalHeightDpi().
 *  If the physical resolution could not be retrieved, these methods return -1.
 * 2002-04-23 Added support for the new properties physical resolution and comments for some 
 * formats. Released as 1.2.
 * 2002-06-17 Added support for SWF, sent in by Michael Aird.
 *  Changed checkJpeg() so that other APP markers than APP0 will not lead to a failure anymore.
 *  Released as 1.3.
 * 2003-07-28 Bug fix - skip method now takes return values into consideration. Less bytes than 
 *  necessary may have been skipped, leading to flaws in the retrieved information in some cases.
 *  Thanks to Bernard Bernstein for pointing that out.
 *  Released as 1.4.
 * 2004-02-29 Added support for recognizing progressive JPEG and interlaced PNG and GIF. A new 
 *  method isProgressive() returns whether ImageInfo has found that the storage type is 
 *  progressive (or interlaced). 
 *  Thanks to Joe Germuska for suggesting the feature.
 *  Bug fix: BMP physical resolution is now correctly determined.
 *  Released as 1.5.
 * 2004-11-30 Bug fix: recognizing progressive GIFs (interlaced in GIF terminology) did not work 
 *  (thanks to Franz Jeitler for pointing this out). Now it should work, but only if the number 
 *  of images is determined. This is because information on interlacing is stored in a local 
 *  image header. In theory, different images could be stored interlaced and non-interlaced in 
 *  one File. However, I think  that's unlikely. Right now, the last image in the GIF File 
 *  that is examined by ImageInfo is used for the "progressive" status.
 * 2005-01-02 Some code clean up (unused methods and variables commented out, missing javadoc 
 *  comments, etc.). Thanks to George Sexton for a long list.
 *  Removed usage of Boolean.toString because it's a Java 1.4+ feature (thanks to Gregor Dupont).
 *  Changed delimiter character in compact output from semicolon to tabulator (for better 
 *  integration with cut(1) and other Unix tools).
 *  Added some points to the <a href="http://schmidt.devlib.org/image-info/index.html#knownissues">
 *  'Known issues' section of the website</a>. 
 *  Released as 1.6.
 * 2005-07-26 Removed code to identify Flash (SWF) files. Has repeatedly led to problems and 
 *  support requests, and I don't know the format and don't have the time and interest to fix it 
 *  myself. I repeatedly included fixes by others which didn't work for some people. I give up 
 *  on SWF. Please do not contact me about it anymore.
 *  Set package of ImageInfo class to org.devlib.schmidt.imageinfo (a package was repeatedly 
 *  requested by some users).
 *  Released as 1.7.
 * 2006-02-23 Removed Flash helper methods which weren't used elsewhere.
 *  Updated skip method which tries "read" whenever "skip(Bytes)" returns a result of 0. The 
 *  old method didn't work with certain input stream types on truncated data streams.
 *  Thanks to Martin Leidig for reporting this and sending in code.
 *  Released as 1.8.
 * 2006-11-13 Removed check that made ImageInfo report JPEG APPx markers smaller than 14 bytes 
 *  as files in unknown format. Such JPEGs seem to be generated by Google's Picasa application. 
 *  First reported with fix by Karl von Randow. Released as 1.9.
 *  
 * 2007-07-30 Converted to C# - except for the CMD parsing methods
 * 2010-02-18 Added tif support and OS/2 BMP
 * 2011-10-16 Added jpx support
 * 2013-05-18 Added support for reading the jp2's color space and tiff striped images
 * 2020-10-06 Targa support
 * 2023-03-06 PNM PAM support. Files with multiple images not tested.
 */
#endregion

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Windows.Media;
//using System.Diagnostics.Tracing;
using System.Diagnostics;

namespace PdfLib.Img
{
    /// <summary>
    /// Get File format, image resolution, number of bits per pixel and optionally 
    /// number of images, comments and physical resolution from 
    /// JPEG, GIF, BMP, PCX, PNG, IFF, RAS, PBM, PGM, PPM, TIF and PSD files 
    /// (or input streams).
    /// </summary>
    /// <remarks>
    /// Known limitations:
    /// <list type="bullet">
    /// <item>When the determination of the number of images is turned off, GIF bits 
    /// per pixel are only read from the global header.
    /// For some GIFs, local palettes change this to a typically larger
    /// value. To be certain to get the correct color depth, call
    /// setDetermineImageNumber(true) before calling check().
    /// The complete scan over the GIF File will take additional time.</item>
    /// <item>Transparency information is not included in the bits per pixel count.
    /// Actually, it was my decision not to include those bits, so it's a feature! ;-)</item>
    /// <item>Tif support is largly untested and will refuse to take valid tif files that
    /// use a planar color mode and stripps simply because I have no such files to Scann with 
    /// and it may affect how File data is read by GetRawData().</item>
    /// <item>Ignores thumbnails and overlay images in tif files. Also ignores all text.</item>
    /// </list>
    /// 
    /// Note: Only works with streams that support seek, but will preserve a stream's origin so
    ///       the image data does not have to begin at position 0.
    /// 
    /// Tiff support:
    ///  Not supported: (Files using these features will return false on "check")*
    ///   - 16 bit strip offsets
    ///   - Planar color mode
    ///   - Extra color info/BitsPerPixel set by color. This is normal enough
    ///     that it should be added
    ///   - Files with images > 2GB can't be read by the getRawData() function
    ///   
    ///   * can safly be put on ignore if getRawData() isn't needed
    /// 
    ///  Ignored:
    ///   - Thumbnails
    ///   - Comments
    ///   - DPI/scaling
    ///   - Layers
    /// </remarks>
    /// <example>
    /// Use the class like this:
    /// <code>
    /// ImageInfo ii = new ImageInfo();
    /// 
    /// //By default ImageInfo will give valid on all supported formats,
    /// //but if this is not be desired use this function:
    /// ii.AddValidFormat(ImageInfo.FORMATS.JPEG);
    /// ii.AddValidFormat(ImageInfo.FORMATS.BMP);
    /// ii.AddValidFormat(ImageInfo.FORMATS.BMP_OS2);
    /// 
    /// //Loads the image
    /// using(FileStream fs = new FileStream("afile.tif"))
    /// {
    ///   ii.DetermineImageCount = true; // default is false
    ///   ii.CollectComments = true; // default is false
    ///   ii.stream = fs; // Set this last for best performance
    ///   if (!ii.valid) {
    ///     Console.Write("Not a supported image File format.");
    ///     return;
    ///   }
    /// 
    ///   //For convinience the stream can be reset to it's origin so:
    ///   ii.stream = null;
    /// 
    ///   //The stream is now at the position it was when handed to image info
    ///   //and can therefore be handed straight to an image loader or closed.
    /// }
    /// 
    /// //Prints basic information
    /// Console.Write(ii.getFormatName() + ", " + ii.getMimeType() + 
    ///  ", " + ii.getWidth() + " x " + ii.getHeight() + " pixels, " + 
    ///  ii.getBitsPerPixel() + " bits per pixel, " + ii.getNumberOfImages() +
    ///  " image(s), " + ii.getNumberOfComments() + " comment(s)."); 
    /// </code>
    /// </example>
    [System.Diagnostics.DebuggerDisplay("Width = {Width}, Height = {Height}", Type = "{_format}")]
    public sealed class ImageInfo
    {
        #region variables

        public enum FORMAT
        {
            UNKNOWN = 0,

            /// <summary>
            /// Return value of getFormat() for JPEG streams.
            /// ImageInfo can extract physical resolution and comments
            /// but only from JPEGs with an APP0 headers.
            /// 
            /// Only one image can be stored in a File.
            /// 
            /// It is determined whether the JPEG stream is progressive 
            /// <see cref="isProgressive()"/>.
            /// </summary>
            JPEG = 1,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for GIF streams.
            /// ImageInfo can extract comments from GIFs and count the number
            /// of images (GIFs with more than one image are animations).
            /// It is determined whether the GIF stream is interlaced 
            /// <see cref="isProgressive()" />.
            /// </summary>
            GIF = 2,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PNG streams.
            /// PNG only supports one image per File.
            /// Both physical resolution and comments can be stored with PNG,
            /// but ImageInfo is currently not able to extract those.
            /// It is determined whether the PNG stream is interlaced
            /// <see cref="isProgressive()" />.
            /// </summary>
            PNG = 3,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for BMP streams.
            /// BMP only supports one image per File.
            /// BMP does not allow for comments.
            /// The physical resolution can be stored.
            /// </summary>
            BMP = 4,

            BMP_OS2 = 5,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PCX streams.
            /// PCX does not allow for comments or more than one image per File.
            /// However, the physical resolution can be stored.
            /// </summary>
            PCX = 6,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for IFF streams.
            /// </summary>
            IFF = 7,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for RAS streams.
            /// Sun Raster allows for one image per File only and is not able to
            /// store physical resolution or comments.
            /// </summary>
            RAS = 8,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PBM streams.
            /// </summary>
            PBM = 9,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PGM streams.
            /// </summary>
            PGM = 10,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PPM streams.
            /// </summary>
            PPM = 11,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PSD streams.
            /// </summary>
            PSD = 12,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for TIFF streams.
            /// </summary>
            TIF = 13,
            BIG_TIF = 14,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for J2K streams.
            /// </summary>
            J2K = 15,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for JP2 streams.
            /// </summary>
            JP2 = 16,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for TGA streams.
            /// </summary>
            TGA = 17,

            /// <summary>
            /// Return value of <see cref="getFormat()" /> for PNMv7 streams.
            /// </summary>
            PAM = 18,
#if CELESTE
            /// <summary>
            /// Return value of <see cref="getFormat()" /> for Celeste game image streams.
            /// </summary>
            Celeste = 19
#endif
        }

        public enum COLORSPACE
        {
            JPX_UNKNOWN = -2,
            UNSPECIFIED = -1,
            UNKNOWN = 0,
            CMY = 11,
            CMYK = 12,
            YCCK = 13,
            CIELab = 14,
            sRGB = 16,
            GRAY = 17,
            sYCC = 18, // YUV
        }

        /// <summary>
        /// List containing valid formats. 
        /// </summary>
        private Dictionary<FORMAT, bool> _formats = null;

        /// <summary>
        /// The various ifd field types that exists in a tiff File.
        /// </summary>
        public enum TYPE
        {
            BOOL = 0,
            BYTE = 1,
            ASCII,

            /// <summary>
            /// Unsigned 16-bit integer
            /// </summary>
            SHORT,

            /// <summary>
            /// Unsigned 32-bit integer
            /// </summary>
            LONG,

            ///<summary>
            ///RATIONAL is an offset to a 64-bit number where the first 
            ///32-bit are to be devided on the last 32-bit
            ///</summary>
            RATIONAL,
            SBYTE,
            UNDEFINED,
            SSHORT,

            /// <summary>
            /// Signed 32 bit integer
            /// </summary>
            SLONG,
            SRATIONAL,
            FLOAT,
            DOUBLE
        }

        /// <summary>
        /// Options for G3 encoded images
        /// </summary>
        public class T4Options
        {
            #region Variables and properties

            readonly uint _value;
            readonly bool _fill_order;

            /// <summary>
            /// If this image use 2D coding
            /// </summary>
            /// <remarks>K value should be a multiple of n rows on 2D coding</remarks>
            public bool TwoDimensional { get { return (_value & 1) == 1; } }

            /// <summary>
            /// If uncompressed mode is used
            /// </summary>
            public bool Uncompessed { get { return (_value & 2) == 2; } }

            /// <summary>
            /// If the rows are byte aligned
            /// </summary>
            public bool ByteAligned { get { return (_value & 4) == 4; } }

            /// <summary>
            /// True reverses black and white
            /// </summary>
            public bool FillOrder { get { return _fill_order; } }

            /// <summary>
            /// The raw T4 option value
            /// </summary>
            public uint Value { get { return _value; } }

            #endregion

            #region Init

            internal T4Options(uint value, bool fill_order) { _value = value; _fill_order = fill_order; }

            #endregion
        }

        /// <summary>
        /// Information about one image
        /// </summary>
        [System.Diagnostics.DebuggerDisplay("Width = {Width}, Height = {Height}", Type = "{Compression}")]
        public class Info
        {
            public int Height = 0;
            public int Width = 0;
            public int BitsPerPixel = 1;
            public readonly Dictionary<Tag.ID, Tag> Tags = new Dictionary<Tag.ID, Tag>();
            internal short[] _bits_per_sample;

            /// <summary>
            /// If J2P images has alpha embeded in the data
            /// </summary>
            public bool HasAlpha
            {
                get
                {
                    Tag t = null;
                    return Tags.TryGetValue(Tag.ID.HasAlpha, out t) ? t.BValue : false;
                }
            }

            /// <summary>
            /// LZW compressed images can have predicor
            /// </summary>
            public bool HasPredicor
            {
                get
                {
                    Tag t = null;
                    return Tags.TryGetValue(Tag.ID.Predictor, out t) ? t.Value == 2 : false;
                }
            }

            /// <summary>
            /// True = lsb2msb
            /// </summary>
            public bool FillOrder
            {
                get
                {
                    Tag t = null;
                    return Tags.TryGetValue(Tag.ID.FILLORDER, out t) ? t.BValue : false;
                }
            }

            public bool BlackIsOne
            {
                get
                {
                    const Tag.ID i = Tag.ID.PhotometricInterpretation;
                    Tag t = null;
                    return Tags.TryGetValue(i, out t) ? t.Value == 1 : false;
                }
            }

            public T4Options T4Options
            {
                get
                {
                    if (Compression != COMPRESSION_SCHEME.CCITT_G3)
                        return null;
                    Tag t = null;
                    bool fo = Tags.TryGetValue(Tag.ID.FILLORDER, out t) ? t.BValue : false;
                    if (!Tags.ContainsKey(Tag.ID.T4OPTIONS))
                        return new T4Options(0, fo);
                    return new T4Options(Tags[Tag.ID.T4OPTIONS].UValue, fo);
                }
            }

            /// <summary>
            /// How many bits are in each color.
            /// </summary>
            /// <remarks>Colors are sepperated by "-"</remarks>
            public string BitsPerColor
            {
                get
                {
                    const Tag.ID i = Tag.ID.BitsPerSample;
                    Tag t = null;
                    if (!Tags.TryGetValue(i, out t))
                        return "" + BitsPerPixel;
                    return t.Comment;
                }
            }

            /// <summary>
            /// Returns -1 if samples are uneaven
            /// </summary>
            public short BitsPerSample
            {
                get
                {
                    if (_bits_per_sample == null || _bits_per_sample.Length == 0)
                        return (short)(BitsPerPixel / NComponents);
                    short sample = _bits_per_sample[0];
                    for (int c = 1; c < _bits_per_sample.Length; c++)
                        if (_bits_per_sample[c] != sample)
                            return -1;
                    return sample;
                }
            }

            public int NStrips
            {
                get
                {
                    Tag t = null;
                    if (!Tags.TryGetValue(Tag.ID.STRIPBYTECOUNT, out t))
                        return 1;
                    return (int)t.Count;
                }
            }

            public int RowsPerStrip
            {
                get
                {
                    const Tag.ID i = Tag.ID.ROWSPERSTRIP;
                    Tag t = null;
                    if (!Tags.TryGetValue(i, out t))
                        return int.MaxValue;
                    return t.Value;
                }
            }

            /// <summary>
            /// Returns if the image should be rotated.
            /// </summary>
            /// <remarks>
            /// TIFF files also supports flipping, but 
            /// that will be ignored and zero returned.
            /// </remarks>
            public int Rotation
            {
                get
                {
                    const Tag.ID i = Tag.ID.ORIENTATION;
                    Tag t = null;
                    if (Tags.TryGetValue(i, out t))
                    {
                        if (t.Value == 8)
                            return 270;
                        if (t.Value == 3)
                            return 180;
                        if (t.Value == 6)
                            return 90;
                    }
                    return 0;
                }
            }

            public COMPRESSION_SCHEME Compression
            {
                get
                {
                    const Tag.ID i = Tag.ID.COMPRESSION_SCHEME;
                    Tag t = null;
                    if (Tags.TryGetValue(i, out t))
                        return (COMPRESSION_SCHEME)t.Value;
                    return COMPRESSION_SCHEME.UNDEFINED;
                }
                set
                {
                    const Tag.ID i = Tag.ID.COMPRESSION_SCHEME;
                    Tags[i] = new Tag(i, TYPE.SLONG, 1, (int)value);
                }
            }

            public int NComponents
            {
                get
                {
                    const Tag.ID i = Tag.ID.SAMPLESPERPIXEL;
                    Tag t = null;
                    if (Tags.TryGetValue(i, out t))
                        return t.Value;
                    return BitsPerColor.Split('-').Length;
                }
                set
                {
                    const Tag.ID i = Tag.ID.SAMPLESPERPIXEL;
                    Tags[i] = new Tag(i, TYPE.SLONG, 1, value);
                }
            }

            /// <summary>
            /// Comments found in Jpeg and Gif files
            /// </summary>
            public int CommentCount
            {
                get
                {
                    const Tag.ID i = Tag.ID.COMMENTCOUNT;
                    Tag t = null;
                    return Tags.TryGetValue(i, out t) ? t.Value : 0;
                }
                set
                {
                    const Tag.ID i = Tag.ID.COMMENTCOUNT;
                    Tags[i] = new Tag(i, TYPE.SLONG, 1, value);
                }
            }

            public int XResolution
            {
                get
                {
                    const Tag.ID i = Tag.ID.XRESOLUTION;
                    Tag t = null;
                    return Tags.TryGetValue(i, out t) ? t.Value : 0;
                }
                set { Tags[(Tag.ID)282] = new Tag((Tag.ID)282, TYPE.SLONG, 1, value); }
            }

            public int YResolution
            {
                get
                {
                    const Tag.ID i = Tag.ID.YRESOLUTION;
                    Tag t = null;
                    return Tags.TryGetValue(i, out t) ? t.Value : 0;
                }
                set { Tags[(Tag.ID)283] = new Tag((Tag.ID)283, TYPE.SLONG, 1, value); }
            }

            public bool Progressive
            {
                get
                {
                    const Tag.ID i = Tag.ID.PROGRESSIVE;
                    Tag t = null;
                    return Tags.TryGetValue(i, out t) ? t.BValue : false;
                }
                set { Tags[(int)Tag.ID.PROGRESSIVE] = new Tag((int)Tag.ID.PROGRESSIVE, value); }
            }

            public bool Valid
            {
                get { return Height > 0 && Width > 0 && BitsPerPixel > 0; }
            }

            /// <summary>
            /// Size of the compressed raw data. 
            /// </summary>
            public uint CompressedSize
            {
                get
                {
                    const Tag.ID i = Tag.ID.STRIPBYTECOUNT;
                    Tag t = null;
                    if (!Tags.TryGetValue(i, out t))
                        return 0;

                    //Todo - can strips be of variable byte sizes? Note that I currently
                    //require that count values mach up for strip offsets and bytecount
                    if (t.IsOffset)
                        return 0;

                    //Forumlas from the spec: (note uint.maxval is commonly used for RowsPerStrip)
                    //uint StripsPerImage = (uint)Math.Floor((double)(Height + RowsPerStrip - 1) / RowsPerStrip);
                    //return StripByteCount * (uint) StripsPerImage;

                    return t.UValue;
                }
            }

            public void AddComment(string comment)
            {
                Tag.ID i = Tag.ID.COMMENT + CommentCount;
                CommentCount++;
                Tags[i] = new Tag(i, comment);
            }
            /// <summary>
            /// Adds a comment from a stream
            /// </summary>
            public void AddComment(Tag t, Stream s)
            {
                if (t.Type != TYPE.ASCII)
                    return;

                byte[] str = t.GetBytes(s);
                string comment = Encoding.ASCII.GetString(str);
                if (comment[comment.Length - 1] == '\0')
                    comment = comment.Substring(0, comment.Length - 1);
                AddComment(comment.Trim());
            }
        }

        /// <summary>
        /// The various images can have additional information. This information
        /// will be stored away in Tiff like "Tags".
        /// </summary>
		[System.Diagnostics.DebuggerDisplay("{Id}")]
        public class Tag
        {
            public readonly ID Id;
            public readonly TYPE Type;
            public readonly uint Count;
            public readonly long LValue;
            public int Value { get { return (int)LValue; } }
            public uint UValue { get { return (uint)LValue; } }
            public bool BValue { get { return LValue == 1; } }
            public string Comment;

            /// <summary>
            /// If this tag is a value or an offset into the File.
            /// </summary>
            public bool IsOffset
            {
                get
                {
                    if (Count > 1)
                    {
                        int len = 4;
                        if (Type == TYPE.SHORT)
                            len = 2;
                        if (Count * len > 4)
                            return true;
                        return false;
                    }
                    return Type == TYPE.RATIONAL || Type == TYPE.SRATIONAL || Type == TYPE.DOUBLE;
                }
            }

            /// <summary>
            /// Constructor intended for tiff images
            /// </summary>
            /// <param name="id">Tag's identifier</param>
            /// <param name="type"></param>
            /// <param name="count">How many values</param>
            /// <param name="value">Values less than 4 bytes or offset</param>
            public Tag(ID id, TYPE type, uint count, uint value)
            {
                Id = id;
                Type = type;
                Count = count;
                LValue = value;
                Comment = NA;
            }

            /// <summary>
            /// Constructor intended for tiff images
            /// </summary>
            /// <param name="id">Tag's identifier</param>
            /// <param name="value">32-bit signed int</param>
            public Tag(ID id, int value)
            {
                Id = id;
                Type = TYPE.SLONG;
                Count = 1;
                LValue = value;
                Comment = NA;
            }

            /// <summary>
            /// Constructor intended for tiff images
            /// </summary>
            /// <param name="id">Tag's identifier</param>
            /// <param name="value">32-bit unsigned int</param>
            public Tag(ID id, uint value)
            {
                Id = id;
                Type = TYPE.LONG;
                Count = 1;
                LValue = value;
                Comment = NA;
            }

            /// <summary>
            /// Constructor intended for tiff images
            /// </summary>
            /// <param name="tagName">Human readable name of the tag</param>
            /// <param name="id">Tag's identifier</param>
            /// <param name="type"></param>
            /// <param name="count">How many values</param>
            /// <param name="value">Values less the 4 bytes or offset</param>
            public Tag(ID id, TYPE type, int count, int value)
            {
                Id = id;
                Type = type;
                Count = (uint)count;
                LValue = value;
                Comment = NA;
            }

            /// <summary>
            /// Constructor intended for true/false values
            /// </summary>
            /// <param name="tagName">Human readable name of the tag</param>
            /// <param name="id">Tag's identifier</param>
            /// <param name="type"></param>
            /// <param name="count">How many values</param>
            /// <param name="value">Values less the 4 bytes or offset</param>
            public Tag(ID id, bool value)
            {
                Id = id;
                Type = TYPE.BOOL;
                Count = 1U;
                LValue = value ? TRUE : FALSE;
                Comment = NA;
            }

            /// <summary>
            /// Constructor intended for Jpeg images
            /// </summary>
            /// <param name="comment"></param>
            public Tag(ID comment_nr, string comment)
            {
                Id = comment_nr;
                Type = TYPE.UNDEFINED;
                Count = 1;
                LValue = 0;
                Comment = comment;
            }

            /// <summary>
            /// Gets an array of shorts
            /// </summary>
            /// <param name="s">Stream to read from</param>
            /// <param name="bigE">Big endian</param>
            /// <returns></returns>
            public ushort[] GetUShorts(Stream s, bool bigE)
            {
                byte[] ba = GetBytes(s);
                ushort[] sa = new ushort[Count];

                int b = 0;
                for (int c = 0; c < Count; c++)
                {
                    sa[c] = (ushort)readShort(ba, b, bigE);
                    b += 2;
                }

                return sa;
            }

            /// <summary>
            /// Gets an array of shorts
            /// </summary>
            /// <param name="s">Stream to read from</param>
            /// <param name="bigE">Big endian</param>
            /// <returns></returns>
            public short[] GetShorts(Stream s, bool bigE)
            {
                byte[] ba = GetBytes(s);
                if (ba == null) return null;
                short[] sa = new short[Count];

                int b = 0;
                for (int c = 0; c < Count; c++)
                {
                    sa[c] = (short)readShort(ba, b, bigE);
                    b += 2;
                }

                return sa;
            }

            /// <summary>
            /// Gets the bytes from a stream
            /// </summary>
            /// <remarks>Assumes offset is from the
            /// start of the stream</remarks>
            public byte[] GetBytes(Stream s)
            {
                if (IsOffset)
                {
                    uint length = (uint)TagSize * Count;
                    byte[] ret = new byte[length];
                    long pos = s.Position;
                    s.Seek(UValue, SeekOrigin.Begin);
                    int read = s.Read(ret, 0, (int)length);
                    s.Seek(pos, SeekOrigin.Begin);
                    if (read != length)
                        return null;
                    return ret;
                }
                else
                {
                    //throw new NotImplementedException();
                    return Read.Lexer.GetBytes(false, UValue);
                }
            }

            public int TagSize
            {
                get
                {
                    int length = 4;
                    switch (Type)
                    {
                        default:
                            break;
                        case TYPE.ASCII:
                        case TYPE.BYTE:
                            length = 1;
                            break;
                        case TYPE.DOUBLE:
                        case TYPE.RATIONAL:
                        case TYPE.SRATIONAL:
                            length = 8;
                            break;
                        case TYPE.SHORT:
                        case TYPE.SSHORT:
                            length = 2;
                            break;
                    }
                    return length;
                }
            }

            /// <summary>
            /// Reads an 16-bit integer and corrects for endianess
            /// </summary>
            /// <param name="a">The array to read from</param>
            /// <param name="offs">offset into the array</param>
            private int readShort(byte[] a, int offs, bool big)
            {
                return big ? GetUShortBigEndian(a, offs) : GetUShortLittleEndian(a, offs);
            }

            public enum ID
            {
                /// <summary>
                /// Tag used to keep track of the number of comments. 
                /// </summary>
                COMMENTCOUNT = -50,
                PROGRESSIVE = 0,
                NewSubfileType = 254,
                ImageWidth = 256,
                ImageLength = 257,
                BitsPerSample = 258,
                COMPRESSION_SCHEME = 259,
                /// <summary>
                /// WhiteIsZero 0
                /// BlackIsZero 1
                /// RGB 2
                /// RGB Palette 3
                /// Transparency mask 4
                /// CMYK 5
                /// YCbCr 6
                /// CIELab 8
                /// </summary>
                PhotometricInterpretation = 262,

                /// <summary>
                /// The logical order of bits within a byte
                /// 
                /// True - LSB2MSB
                /// False - MSB2LSB
                /// </summary>
                FILLORDER = 266,
                DocumentName = 269,
                STRIPOFFSETS = 273,
                ORIENTATION = 274,
                SAMPLESPERPIXEL = 277,
                ROWSPERSTRIP,
                STRIPBYTECOUNT,
                XRESOLUTION = 282,
                YRESOLUTION,
                /// <summary>
                /// How the colors are laid out. 
                /// 
                /// True - Planar
                /// False - Chuncy
                /// </summary>
                PLANARCONFIGURATION,
                T4OPTIONS = 292,
                T6OPTIONS,
                Predictor = 317,
                CLEANFAXDATA = 327,

                /// <summary>
                /// Comments must have an unique ID. Since Tiff tag ids are 16-bit we simply
                /// add this number to the comment_nr to insure that there won't be a 
                /// collision.
                /// </summary>
                COMMENT = ushort.MaxValue + 1,

                /// <summary>
                /// Used by J2P images
                /// </summary>
                HasAlpha
            }

            public static readonly string NA = "N/A";
            public const int TRUE = 1;
            public const int FALSE = 0;
        }

        /// <summary>
        /// Common compression schemes used in tiff images. Tiff can also support other schemes.
        /// </summary>
        public enum COMPRESSION_SCHEME
        {
            UNDEFINED = -1,
            UNCOMPRESSED = 1,
            CCITT_MOD_HUFF_RLE,
            CCITT_G3,
            CCITT_G4,
            LZW,
            old_JPEG,
            JPEG,
            ADOBE_DEFLATE,
            JBIG_BW,
            JBIG_C,
            JP_2000 = 34712,
            PACKBITS = 32773
        }
        /// <summary>
        /// Options for CCITT_G3 compression.
        /// </summary>
        public enum CCITT_G3_OPT
        {
            _1DENCODING = 0,
            _2DENCODING,
            UNCOMPRESSED,
            FILLBITS
        }

        /// <summary>
        /// The names of all supported File formats.
        /// The FORMAT_xyz int constants can be used as index values for
        /// this array.
        /// </summary>
        private static readonly string[] FORMAT_EXTENSION =
        {"Unknown", "JPEG", "GIF", "PNG", "BMP", "BMP",
         "PCX", "IFF", "RAS", "PBM", "PGM", "PPM",
         "PSD", "TIF", "J2K", "JP2" };

        /// <summary>
        /// The names of the MIME types for all supported File formats.
        /// The FORMAT_xyz int constants can be used as index values for
        /// this array.
        /// </summary>
        private static readonly string[] MIME_TYPE_STRINGS =
        {"Unknown", "image/jpeg", "image/gif", "image/png", "image/bmp", "image/pcx",
         "image/iff", "image/ras", "image/x-portable-bitmap", "image/x-portable-graymap", "image/x-portable-pixmap",
         "image/psd", "image/tiff", "image/jp2", "image/jp2" };

        /// <summary>
        /// Image being "viewed" when checking ImageInfo's properties
        /// </summary>
        private Info _current_image;

        /// <summary>
        /// The image container format (Tiff, jpeg, etc)
        /// </summary>
        private FORMAT _format = FORMAT.UNKNOWN;

        /// <summary>
        /// Stream used to read in the image. The stream must support seeks.
        /// </summary>
        private Stream _inn;

        /// <summary>
        /// Where the stream started from.
        /// </summary>
        private long _inn_origin = 0;

        /// <summary>
        /// Whenever to store away comments found in a Jpeg File.
        /// </summary>
        private bool _collectComments = false;

        /// <summary>
        /// Whenever the current image is valid or not. 
        /// </summary>
        private bool _valid = false;

        /// <summary>
        /// Whenever to search through the File for more images.
        /// </summary>
        private bool _determineNumberOfImages;

        /// <summary>
        /// Targa images are tricky, so we only check for them if this flag is set
        /// </summary>
        private bool _checkIfTarga;

#if CELESTE
        /// <summary>
        /// Celeste images are tricky, so we only check for them if this flag is set
        /// </summary>
        private bool _checkIfCeleste;
#endif

        /// <summary>
        /// How many images were discovered in the container.
        /// </summary>
        private int _numberOfImages;

        /** Used for TIFF images **/

        /// <summary>
        /// Image has High to Low byte order
        /// </summary>
        private bool _bigEndian = false;

        /// <summary>
        /// List of images in a tiff container
        /// </summary>
        private List<Info> _images = null;

        /// <summary>
        /// The current image being shown in a tiff container
        /// </summary>
        private int _selected_image = -1;

        /// <summary>
        /// If there are more images in a tiff the container, this value points to the next IDF.
        /// </summary>
        private uint _next_offset = 0;

        #endregion

        /// <summary>
        /// Parameterless constructor
        /// </summary>
        public ImageInfo() { _current_image = new Info(); }

        /// <summary>
        /// Construct ImageInfo from a byte array
        /// </summary>
        public ImageInfo(byte[] image)
            : this(new MemoryStream(image))
        { }

        /// <summary>
        /// Construct ImageInfo with a data source.
        /// </summary>
        public ImageInfo(Stream image)
        {
            Stream = image;
        }

        /// <summary>
        /// Construct ImageInfo with a data source.
        /// </summary>
        /// <param name="image">FileStream to the image</param>
        /// <param name="scan_whole_file">Some images have comments and multiple
        /// images. If true ImageInfo will look through those files for more
        /// info.</param>
        public ImageInfo(Stream image, bool scan_whole_file)
        {
            _collectComments = scan_whole_file;
            _determineNumberOfImages = scan_whole_file;
            Stream = image;
        }

        #region check methods

        public bool Valid
        {
            get { return _valid; }
        }

        /// <summary>
        /// Checks if the given image is valid
        /// </summary>
        public bool Check(string image_path)
        {
            using (FileStream fs = new FileStream(image_path, FileMode.Open))
            {
                Stream = fs;
                return Valid;
            }
        }

        /// <summary>
        /// Rechecks an image
        /// </summary>
        /// <returns>Imagedata is valid</returns>
        private bool recheck()
        {
            if (_inn == null)
                return false;
            _inn.Seek(_inn_origin, SeekOrigin.Begin);
            return check();
        }

        /// <summary>
        /// Checks the image stream
        /// </summary>
        /// <remarks>
        /// All IO exceptions are swallowed.
        /// </remarks>
        /// <returns>If true is returned the File format was known and information on the 
        /// File's content can be retrieved using the various getXyz methods.</returns>
        private bool check()
        {
            _format = FORMAT.UNKNOWN;
            _current_image = new Info();
            _numberOfImages = 0;
            _bigEndian = false;
            try
            {
                int b1 = read();
                int b2 = read();
                switch (b1)
                {
                    case 0x00:
                        if (b2 == 0x00) checkJp2();
                        break;
                    case 0x0a:
                        if (b2 == 0x06) checkPcx();
                        break;
                    case 0x38:
                        if (b2 == 0x42) checkPsd();
                        break;
                    case 0x42:
                        if (b2 == 0x4d) checkBmp();
                        break;
                    case 0x46:
                        if (b2 == 0x4f) checkIff();
                        break;
                    case 0x47:
                        if (b2 == 0x49) checkGif();
                        break;
                    case 0x49:
                        if (b2 == 0x49 && checkTiff(false)) _format = FORMAT.TIF;
                        break;
                    case 0x4D:
                        if (b2 == 0x4D && checkTiff(true)) _format = FORMAT.TIF;
                        break;
                    case 0x50:
                        if (b2 >= 0x31 && b2 <= 0x36) 
                            checkPnm(b2 - '0');
                        else if (b2 == 0x37)
                            checkPnm();
                        break;
                    case 0x59:
                        if (b2 == 0xa6) checkRas();
                        break;
                    case 0x89:
                        if (b2 == 0x50) checkPng();
                        break;
                    case 0xff:
                        if (b2 == 0xd8) checkJpeg();
                        else if (b2 == 0x4F) checkJ2k();
                        break;
                    default:
                        if (CheckIfTargaFormat)
                            break;
#if CELESTE
                        if (CheckIfCelesteFormat)
                            break;
#endif
                        return false;
                }

                if (_formats != null && _format != FORMAT.UNKNOWN)
                    return _formats.ContainsKey(_format);

                if (CheckIfTargaFormat && b1 != -1 && b2 != -1)
                {
                    _inn.Seek(2, SeekOrigin.Begin);
                    checkTga((byte)b1, (byte)b2);
                    if (_formats != null)
                        return _formats.ContainsKey(_format);
                }

#if CELESTE
                if (CheckIfCelesteFormat && b1 != -1 && b2 != -1)
                {
                    _inn.Seek(2, SeekOrigin.Begin);
                    checkCeleste((byte)b1, (byte)b2);
                    if (_formats != null)
                        return _formats.ContainsKey(_format);
                }
#endif

                return _format != FORMAT.UNKNOWN;
            }
            catch (IOException)
            {
                return false;
            }
        }

        public static bool CompareArrays(byte[] b1, byte[] b2)
        {
            if (b1.Length != b2.Length)
                return false;
            for (int c = 0; c < b1.Length; c++)
                if (b1[c] != b2[c])
                    return false;
            return true;
        }

        private void checkTga(byte id_length, byte color_map_type)
        {
            if (color_map_type > 1) return;

            _bigEndian = false;

            //First check for footer
            const int HeaderByteLength = 18;
            //const int FooterOffsetFromEnd = 18;
            //byte[] FooterASCIISignature = new byte[] { 84, 82, 85, 69, 86, 73, 83, 73, 79, 78, 45, 88, 70, 73, 76, 69 }; // "TRUEVISION-XFILE"

            //We can be certain that this isn't a TGA file if it's this small
            if (_inn.Length < HeaderByteLength)
                return;

            //bool tga20 = false;

            ////Checks for a footer
            //if (_inn.Length > (FooterOffsetFromEnd + HeaderByteLength))
            //{
            //    _inn.Seek(-FooterOffsetFromEnd, SeekOrigin.End);
            //    byte[] footer = new byte[FooterASCIISignature.Length];

            //    //This read is so small the chance of not everything being read is negiable. If it happens, this will be treated as a tga10 image.
            //    _inn.Read(footer, 0, footer.Length);

            //    tga20 = CompareArrays(footer, FooterASCIISignature);

            //    _inn.Seek(2, SeekOrigin.Begin);
            //}

            //We'll have to blindly assume this is a tga image and check if the resulting values makes sense
            byte[] header = new byte[HeaderByteLength - 2];
            if (_inn.Read(header, 0, header.Length) != header.Length)
                return;
            int pos = 0;
            byte image_type = header[pos];
            pos++;

            if (image_type == 0 || image_type > 11 || image_type > 3 && image_type < 9)
                return;
            if (color_map_type == 1)
            {
                if (image_type != 1 && image_type != 9)
                    return;
            }
            else
            {
                if (image_type == 1 || image_type == 9)
                    return;
            }

            int first_colormap_index = readUShort(header, pos);
            pos += 2;
            int color_map_length = readUShort(header, pos);
            pos += 2;
            int color_map_entery_size = header[pos];
            pos++;
            if (color_map_type == 0)
            {
                if (first_colormap_index != 0 || color_map_length != 0 || color_map_entery_size != 0)
                    return;
            }
            else
            {
                if (color_map_length == 0 || color_map_entery_size == 0)
                    return;
            }

            //int x_origin = readUShort(header, pos);
            pos += 2;
            //int y_origin = readUShort(header, pos);
            pos += 2;
            int width = readUShort(header, pos);
            pos += 2;
            int height = readUShort(header, pos);
            pos += 2;
            int bpp = header[pos++];
            int bppa = header[pos++] & 0x0F;

            //Tga only supports 8, 16, 24 and 32 pixel depth
            if (width == 0 || height == 0 || bpp != 8 && bpp != 16 && bpp != 24 && bpp != 32)
                return;

            //Atribute bits per pixel, only 1 or 8 is supported
            if (bppa != 0 && bppa != 1 && bppa != 8)
                return;

            Info img = _current_image;
            img.Width = width;
            img.Height = height;
            img.BitsPerPixel = bpp;
            if (bppa != 0)
                img.Tags[Tag.ID.HasAlpha] = new Tag(Tag.ID.HasAlpha, true);

            if (image_type < 9)
            {
                //This is an uncompressed image, so we can calculate the size of the data.
                int stride = (width * bpp + 7) / 8;
                int size = height * stride;

                if (size > _inn.Length)
                    return;
            }

            _format = FORMAT.TGA;
        }

#if CELESTE
        private void checkCeleste(byte width_b1, byte width_b2)
        {
            //First check for header
            const int HeaderByteLength = 9;

            if (_inn.Length < HeaderByteLength - 2)
                return;

            byte[] header = new byte[HeaderByteLength];
            header[0] = width_b1; header[1] = width_b2;
            if (_inn.Read(header, 2, HeaderByteLength - 2) != HeaderByteLength - 2)
                return;

            _bigEndian = false;
            Info img = _current_image;
            img.Width = readInt(header, 0);
            img.Height = readInt(header, 4);
            img.BitsPerPixel = (header[8] == 0) ? 24 : 32;
            if (header[8] != 0)
                img.Tags[Tag.ID.HasAlpha] = new Tag(Tag.ID.HasAlpha, true);

            //I don't think any celeste images are this big
            if (img.Width < 8192 && img.Height < 8192)
                _format = FORMAT.Celeste;
        }
#endif

            /// <remarks>
            /// Coded with help of the TIFF 6 reference PDF. 
            /// Tag info from AWARE [SYSTEMS] http://www.awaresystems.be/imaging/tiff/tifftags/
            /// 
            /// This function is a bit too aggressive on error checking, there's no real need to
            /// check on field types, counts and such but I prefer that corrupt files are weeded
            /// out instead of me thinking I got some subtle bug in my algorithm later on.
            /// </remarks>
            private bool checkTiff(bool big_endian)
        {
            //Some constants to make the code a little more readable
            const int HEADER_LENGTH = 8;
            const int SHORT = 2;

            if (_inn.Length > uint.MaxValue) return false;
            _bigEndian = big_endian;
            _numberOfImages = 0;
            _images = null;


            //Creates an array big enough to contain a header, first two bytes
            //are already checked by the caller.
            byte[] ifd = new byte[HEADER_LENGTH - 2];

            //Reads in and checks that "42" is in the TIFF header.
            if (read(ifd, 0, ifd.Length) != ifd.Length)
                return false;

            var version = readUShort(ifd, 0);
            if (version != 42)
            {
                if (version == 43)
                    _format = FORMAT.BIG_TIF;
                return false;
            }

            //Reads the offset to the first IFD.
            uint ifd_offset = readUInt(ifd, SHORT);

            //The ifd has to point to a byte after the header and sit
            //on a word (2 byte) boundary.
            if (ifd_offset < HEADER_LENGTH || ifd_offset % SHORT != 0) return false;

            //if (_determineNumberOfImages || _collectComments)
            return checkIFDs(ifd_offset);
            //return true;
        }

        /// <summary>
        /// Checks image format descriptors in TIFF files.
        /// </summary>
        /// <param name="ifd_offset">Offset in a filestream pointing at an ifd</param>
        /// <returns>True if the IFD was valid</returns>
        private bool checkIFDs(uint ifd_offset)
        {
            const int ENTERY_LENGTH = 12;
            const int LONG = 4;
            const int SHORT = 2;

            bool cont = false;
            bool multipleImages = false;
            byte[] ifd = new byte[SHORT];

            //Reads the all the ifds
            while (true)
            {
                //Reads the idf entery count from the stream. TODO: Check if offset is invalid before seeking
                if (_inn.Position != ifd_offset && _inn.Seek(ifd_offset + _inn_origin, SeekOrigin.Begin) != ifd_offset)
                    return false;
                if (read(ifd, 0, SHORT) != SHORT)
                    return false;

                //Converts the idf entery count to a number and checks if there's more than one.
                //(there must be at least one entery in a valid ifd).
                int dir_ent = readUShort(ifd, 0);
                if (dir_ent < 1) return false;

                //Calculates the length of the ifd and recreates the byte buffer if needed.
                // "+ LONG" is the offset to the next ifd in the File
                int ifd_length = ENTERY_LENGTH * dir_ent + LONG;
                if (ifd.Length != ifd_length)
                    ifd = new byte[ifd_length];

                //Reads the full ifd from the File, excluding the entery count.
                if (read(ifd) != ifd.Length) return false;

                //For the ifd to be valid the tags must be sorted in ascending order.
                Tag.ID last_tag = 0;

                //Tracks the position in the ifd byte array
                int array_pos = 0;

                //The tag data is collected in a Info object.
                Info img = new Info();
                Dictionary<Tag.ID, Tag> tags = img.Tags;
                uint StripByteCount = 0;
                uint RowsPerStrip = 0;

                //Reads the ifd enteries, one by one.
                for (int i = 0; i < dir_ent; i++)
                {
                    Tag.ID tag = (Tag.ID)readUShort(ifd, array_pos);
                    array_pos += SHORT;
                    if (tag <= last_tag) return false;
                    TYPE field_type = (TYPE)readUShort(ifd, array_pos);
                    array_pos += SHORT;
                    uint value_count = readUInt(ifd, array_pos);
                    array_pos += LONG;
                    uint value_offset = field_type == TYPE.SHORT && value_count == 1 ?
                        readUShort(ifd, array_pos) : readUInt(ifd, array_pos);
                    array_pos += LONG;

                    switch ((int)tag)
                    {
                        case 254: //NewSubfileType
                            if (field_type != TYPE.LONG || value_count != 1) return false;

                            //image is a reduced-resolution version of another image in this TIFF File
                            const int REDUCEDIMAGE = 1;
                            //image is a single page of a multi-page image 
                            const int PAGE = 2;
                            //image defines a transparency mask for another image in this TIFF File
                            const int MASK = 4;

                            //Thumbnails and transparency masks are skipped.
                            if (value_offset == REDUCEDIMAGE || value_offset == MASK)
                            {
                                i = dir_ent;
                                cont = true;
                                continue;
                            }

                            //Tells that this TIFF File contains multiple images.
                            if (value_offset == PAGE)
                            {
                                multipleImages = true;
                                continue;
                            }

                            //Other values are not supported.
                            if (value_offset != 0)
                            {
                                _numberOfImages = 0;
                                return false;
                            }

                            continue;
                        case 256: //Image width
                            if (field_type != TYPE.SHORT && field_type != TYPE.LONG
                              || value_count != 1 || value_offset < 1) return false;

                            if (value_offset > int.MaxValue) return false;
                            img.Width = (int)value_offset;

                            continue;
                        case 257: //Image rows
                            if (field_type != TYPE.SHORT && field_type != TYPE.LONG
                              || value_count != 1 || value_offset < 1) return false;

                            if (value_offset > int.MaxValue) return false;
                            img.Height = (int)value_offset;

                            continue;
                        case 258: //Image bits per pixel
                            if (field_type != TYPE.SHORT || value_count < 1) return false;

                            if (value_count == 1)
                            {
                                if (value_offset > int.MaxValue) return false;
                                img.BitsPerPixel = (int)value_offset;
                                continue;
                            }

                            Tag t = new Tag(tag, field_type, value_count, value_offset);
                            tags[tag] = t;

                            short[] bpp = t.GetShorts(_inn, _bigEndian);
                            if (bpp == null) continue;

                            int BPP = 0, c = 0;
                            t.Comment = "";
                            while (true)
                            {
                                short us = bpp[c];
                                BPP += us;
                                t.Comment += "" + us;
                                if (++c == value_count)
                                    break;
                                t.Comment += "-";
                            }

                            img._bits_per_sample = bpp;
                            img.BitsPerPixel = BPP;

                            continue;
                        case 259: //Compression
                            if (field_type != TYPE.SHORT || value_count != 1 || value_offset < 1) return false;

                            img.Compression = (COMPRESSION_SCHEME)value_offset;
                            if (img.Compression == COMPRESSION_SCHEME.CCITT_G3 || img.Compression == COMPRESSION_SCHEME.CCITT_G4)
                            {
                                img.BitsPerPixel = 1;
                                img._bits_per_sample = new short[] { 1 };
                            }

                            continue;
                        case 262: //Photometric
                            if (field_type != TYPE.SHORT || value_count != 1) return false;

                            if (value_offset > int.MaxValue) return false;
                            tags[tag] = new Tag(tag, (int)value_offset);

                            continue;
                        case 266:
                            if (field_type != TYPE.SHORT || value_count != 1) return false;

                            //If fillCS order is corrupt (not 1 or 2) this leads to MSB2LSB
                            tags[tag] = new Tag(tag, value_offset == 2);
                            continue;
                        case 273: //StripOffset
                            //For each strip, the byte offset of that strip. 
                            //The offset is specified with respect to the beginning of the TIFF File. 
                            //Note that this implies that each strip has a location independent of the 
                            //locations of other strips.
                            //This required field is the only way for a reader to find the image data. 
                            //(Unless TileOffsets is used; see TileOffsets.)
                            if (field_type != TYPE.SHORT && field_type != TYPE.LONG || value_count < 1)
                                return false;

                            tags[tag] = new Tag(tag, field_type, value_count, value_offset);
                            continue;
                        case 274: //Orientation
                            if (field_type != TYPE.SHORT || value_count != 1 || value_offset < 1) return false;

                            if (value_offset > int.MaxValue) return false;
                            tags[tag] = new Tag(tag, (int)value_offset);

                            continue;
                        case 277: //SamplesPerPixel
                            if (field_type != TYPE.SHORT || value_count != 1 || value_offset < 1) return false;

                            if (value_offset > int.MaxValue) return false;
                            tags[tag] = new Tag(tag, (int)value_offset);

                            continue;
                        case 278: //RowsPerStrip
                            if (field_type != TYPE.SHORT && field_type != TYPE.LONG || value_count != 1 || value_offset < 1)
                                return false;

                            tags[tag] = new Tag(tag, value_offset);
                            RowsPerStrip = value_offset;
                            continue;
                        case 279: //StripByteCount
                            if (field_type != TYPE.SHORT && field_type != TYPE.LONG || value_offset < 1)
                                return false;

                            //todo: I belive this is correct - but it's possible this count can be 1
                            //while the other > 1 (meaning all stips are of the same size). 
                            if (tags[Tag.ID.STRIPOFFSETS].Count != value_count) return false;

                            tags[tag] = new Tag(tag, TYPE.LONG, value_count, value_offset);
                            StripByteCount = value_offset;

                            continue;
                        case 282: //XResolution
                        case 283: //YResolution
                            if (field_type != TYPE.RATIONAL) return false;

                            long pos = _inn.Position;
                            _inn.Seek(value_offset + _inn_origin, SeekOrigin.Begin);
                            byte[] num = new byte[8];
                            _inn.Read(num, 0, num.Length);
                            _inn.Seek(pos + _inn_origin, SeekOrigin.Begin);

                            uint numerator = readUInt(num, 0);
                            uint denominator = readUInt(num, 4);

                            //todo: Real floating point or leave it as rational.
                            if (denominator != 0)
                                tags[tag] = new Tag(tag, TYPE.FLOAT, 1, (int)(numerator / denominator));
                            break;
                        case 284: //PlanarConfiguration
                        //todo: The read data method does not work with PlanarConfiguration
                        case 292: //TIFF Tag T4Options (Options for Group 3 Fax compression)
                        case 293: //TIFF Tag T6Options (Options for Group 4 Fax compression)
                        case 296: //ResolutionUnit
                        case 327: // CleanFaxData
                        case 34665: // EXFID data offset.
                        default:
                            tags[tag] = new Tag(tag, field_type, value_count, value_offset);
                            if (_collectComments && field_type == TYPE.ASCII)
                                img.AddComment(tags[tag], _inn);
                            continue; //Unkown tags are ignored.
                    }
                }

                //Sets the next offset.
                ifd_offset = readUInt(ifd, ifd.Length - 4);

                //Some images are skipped (thumbnails)
                if (cont)
                {
                    //Last image in the File has no offset.
                    if (ifd_offset == 0) return _numberOfImages > 0;

                    cont = false;
                    continue;
                }

                //Checks if the image came out okay.
                if (!img.Valid)
                    return false;

                //Stores the image info away
                _numberOfImages++;
                if (_images == null)
                    _images = new List<Info>();
                _images.Add(img);

                //Unfortunatly I see misflagged Tiff files.
                if (ifd_offset != 0)
                    multipleImages = true;
                // The last image in a File must have offset = 0.
                // In case where we only decode one image at a time
                // we expect the multipleImages flag to be set.
                /*if (ifd_offset != 0 && !multipleImages)
                {
                    _numberOfImages = 0;
                    _next_offset = 0;
                    return false;
                }*/

                if (multipleImages && _determineNumberOfImages)
                {
                    if (_numberOfImages == 1)
                    {
                        _selected_image = 0;
                        _current_image = img;
                    }

                    //Last image in the File has no offset.
                    if (ifd_offset == 0)
                    {
                        _next_offset = 0;
                        _format = FORMAT.TIF;
                        return true;
                    }

                    //Sanity checks the offset.
                    if (ifd_offset <= _inn.Position || ifd_offset % 2 != 0)
                    {
                        _numberOfImages = 0;
                        return false;
                    }

                    continue;
                }

                // The last image in a File must have offset = 0.
                // In case where we only decode one image at a time
                // we expect the multipleImages flag to be set.
                if (ifd_offset != 0 && !multipleImages)
                {
                    _numberOfImages = 0;
                    _next_offset = 0;
                    return false;
                }

                _selected_image = 0;
                _current_image = img;
                _format = FORMAT.TIF;
                _next_offset = ifd_offset;

                return true;
            }
        }

        /// <summary>
        /// Add a format for ImageInfo to validate
        /// </summary>
        /// <remarks>
        /// If no valid formats are added all formats supported by imageinfo are assumed valid.
        /// </remarks>
        /// <example>
        /// Say you only want BMP and JPEG images:
        /// <code>
        /// ImageInfo ii = new ImageInfo();
        /// ii.add(ImageInfo.FORMAT.BMP);
        /// ii.add(ImageInfo.FORMAT.JPEG);
        /// </code>
        /// Then ii.valid will only be true when checking a BMP or JPEG image. 
        /// </example>
        /// <param name="ff">Valid format</param>
        public void AddValidFormat(FORMAT ff)
        {
            if (_formats == null)
                _formats = new Dictionary<FORMAT, bool>();

            _formats.Add(ff, true);
        }

        /// <summary>
        /// Set the image selected in a mutliple images fil.
        /// </summary>
        /// <param name="image_nr">Counts from 1</param>
        public void selectImage(int image_nr)
        {
            if (_images == null)
                return;
            image_nr--;
            if (image_nr > 0 && image_nr < _numberOfImages)
            {
                _selected_image = image_nr;
                _current_image = _images[image_nr];
            }
        }

        /// <summary>
        /// Quickly checks BMP files by reading the first 44 bytes.
        /// </summary>
        /// <remarks>Supports V1 and V3 files.</remarks>
        private bool checkBmp()
        {
            //Reads the BMP File header
            byte[] a = new byte[44];
            int read_length = read(a);
            if (read_length < 25)
                return false;

            //Size of the BMP File in bytes.
            uint size = BitConverter.ToUInt32(a, 0);

            //Next four bytes are reserved

            //Offset to bitmap data.
            uint offset = BitConverter.ToUInt32(a, 8);

            //Reads from the DIB header.
            uint header_size = BitConverter.ToUInt32(a, 12);
            Info img = _current_image;
            switch (header_size)
            {
                default:
                    return false;

                case 64: //OS/2 V2
                case 12: //OS/2 V1
                    img.Width = BitConverter.ToUInt16(a, 16);
                    img.Height = BitConverter.ToUInt16(a, 18);

                    //Number of color planes must always equal 1
                    if (BitConverter.ToUInt16(a, 20) != 1)
                        return false;

                    img.BitsPerPixel = BitConverter.ToUInt16(a, 22);
                    _format = FORMAT.BMP_OS2;
                    break;

                case 124: //Windows V5
                case 108: //Windows V4
                case 56: //BITMAPV3INFOHEADER
                case 52: //BITMAPV2INFOHEADER
                case 40: //Windows V3
                    if (read_length < 44) return false;

                    img.Width = BitConverter.ToInt32(a, 16);
                    img.Height = BitConverter.ToInt32(a, 20);

                    //Number of color planes must always equal 1
                    if (BitConverter.ToUInt16(a, 24) != 1)
                        return false;

                    img.BitsPerPixel = BitConverter.ToUInt16(a, 26);

                    int x = (int)(BitConverter.ToUInt32(a, 36) * 0.0254);
                    if (x > 0) img.XResolution = x;

                    int y = (int)(BitConverter.ToUInt32(a, 40) * 0.0254);
                    if (y > 0) img.YResolution = y;

                    _format = FORMAT.BMP;
                    break;
            }

            //Quick sanity check.
            if (!img.Valid || img.BitsPerPixel != 1 && img.BitsPerPixel != 4 &&
                img.BitsPerPixel != 8 && img.BitsPerPixel != 16 &&
                img.BitsPerPixel != 24 && img.BitsPerPixel != 32)
            {
                _format = FORMAT.UNKNOWN;
                return false;
            }

            //Could also check if the various offsets and File sizes are correct.

            _numberOfImages = 1;
            return true;
        }

        private bool checkGif()
        {
            /*const*/
            byte[] GIF_MAGIC_87A = { 0x46, 0x38, 0x37, 0x61 };
            /*const*/
            byte[] GIF_MAGIC_89A = { 0x46, 0x38, 0x39, 0x61 };
            byte[] a = new byte[11]; // 4 from the GIF signature + 7 from the global header
            if (read(a) != 11)
            {
                return false;
            }
            if (!equals(a, 0, GIF_MAGIC_89A, 0, 4) &&
                !equals(a, 0, GIF_MAGIC_87A, 0, 4))
            {
                return false;
            }
            _format = FORMAT.GIF;
            Info img = _current_image;
            img.Width = GetUShortLittleEndian(a, 4);
            img.Height = GetUShortLittleEndian(a, 6);
            int flags = a[8] & 0xff;
            img.BitsPerPixel = (flags >> 4 & 0x07) + 1;
            //progressive = (flags & 0x02) != 0;
            if (!_determineNumberOfImages)
            {
                _numberOfImages = 1;
                return true;
            }
            // skip global color palette
            if ((flags & 0x80) != 0)
            {
                int tableSize = (1 << (flags & 7) + 1) * 3;
                skip(tableSize);
            }
            _numberOfImages = 0;
            int blockType;
            do
            {
                blockType = read();
                switch (blockType)
                {
                    case 0x2c: // image separator
                        {
                            if (read(a, 0, 9) != 9)
                            {
                                return false;
                            }
                            flags = a[8] & 0xff;
                            img.Progressive = (flags & 0x40) != 0;
                            /*int locWidth = getShortLittleEndian(a, 4);
                            int locHeight = getShortLittleEndian(a, 6);
                            System.out.println("LOCAL: " + locWidth + " x " + locHeight);*/
                            int localBitsPerPixel = (flags & 0x07) + 1;
                            if (localBitsPerPixel > img.BitsPerPixel)
                            {
                                img.BitsPerPixel = localBitsPerPixel;
                            }
                            if ((flags & 0x80) != 0)
                            {
                                skip((1 << localBitsPerPixel) * 3);
                            }
                            skip(1); // initial code length
                            int n;
                            do
                            {
                                n = read();
                                if (n > 0)
                                {
                                    skip(n);
                                }
                                else
                                    if (n == -1)
                                {
                                    return false;
                                }
                            }
                            while (n > 0);
                            _numberOfImages++;
                            break;
                        }
                    case 0x21: // extension
                        {
                            int extensionType = read();
                            if (_collectComments && extensionType == 0xfe)
                            {
                                StringBuilder sb = new StringBuilder();
                                int n;
                                do
                                {
                                    n = read();
                                    if (n == -1)
                                    {
                                        return false;
                                    }
                                    if (n > 0)
                                    {
                                        for (int i = 0; i < n; i++)
                                        {
                                            int ch = read();
                                            if (ch == -1)
                                            {
                                                return false;
                                            }
                                            sb.Append((char)ch);
                                        }
                                    }
                                }
                                while (n > 0);
                            }
                            else
                            {
                                int n;
                                do
                                {
                                    n = read();
                                    if (n > 0)
                                    {
                                        skip(n);
                                    }
                                    else
                                        if (n == -1)
                                    {
                                        return false;
                                    }
                                }
                                while (n > 0);
                            }
                            break;
                        }
                    case 0x3b: // end of File
                        {
                            break;
                        }
                    default:
                        {
                            return false;
                        }
                }
            }
            while (blockType != 0x3b);
            return true;
        }

        private bool checkIff()
        {
            byte[] a = new byte[10];
            // read remaining 2 bytes of File id, 4 bytes File size 
            // and 4 bytes IFF subformat
            if (read(a, 0, 10) != 10)
            {
                return false;
            }
            /*const*/
            byte[] IFF_RM = { 0x52, 0x4d };
            if (!equals(a, 0, IFF_RM, 0, 2))
            {
                return false;
            }
            int type = getIntBigEndian(a, 6);
            if (type != 0x494c424d && // type must be ILBM...
                type != 0x50424d20)
            { // ...or PBM
                return false;
            }
            // loop chunks to find BMHD chunk
            Info img = _current_image;
            do
            {
                if (read(a, 0, 8) != 8)
                {
                    return false;
                }
                int chunkId = getIntBigEndian(a, 0);
                int size = getIntBigEndian(a, 4);
                if ((size & 1) == 1)
                {
                    size++;
                }
                if (chunkId == 0x424d4844)
                { // BMHD chunk
                    if (read(a, 0, 9) != 9)
                    {
                        return false;
                    }
                    _format = FORMAT.IFF;
                    img.Width = GetUShortBigEndian(a, 0);
                    img.Height = GetUShortBigEndian(a, 2);
                    img.BitsPerPixel = a[8] & 0xff;
                    if (img.Valid && img.BitsPerPixel < 33)
                    {
                        _numberOfImages = 1;
                        return true;
                    }
                    return false;
                }
                else
                {
                    skip(size);
                }
            } while (true);
        }

        private bool checkJp2()
        {
            bool have_image_header = false;
            bool must_have_bpc_header = false;
            bool must_have_colorspace = false;
            bool has_cdef = false;
            byte[] bits_per_component = null;

            //JPEG 2000 signature box
            const uint JP2_JP = 0x6a502020;

            byte[] data = new byte[14];
            Info img = _current_image;

            //The first four bytes is the length of the signature header.
            //Bug: Assuming that the fist two bytes are zero.
            if (read(data, 0, 2) != 2) return false;
            int length = GetUShortBigEndian(data, 0) - 8;
            if (length < 0) return false;

            //J2P files should start with a signature header. Right? Could
            //always reset the stream back to starpos and go straight to the
            //while loop. 
            if (read(data, 0, 4) != 8 && getUIntBigEndian(data, 0) != JP2_JP)
                return false;

            //We're now reasonble certain we have a Jp2 file. Starts looking for
            //interesting data.
            skip(length);

            //JP2 header box.
            const uint JP2_JP2H = 0x6a703268;

            //Image header box
            const uint JP2_IHDR = 0x69686472;

            //Bits per component box 
            const uint JP2_BPCC = 0x62706363;

            //Bits per component box 
            const uint JP2_COLR = 0x636f6c72;

            //Channel definition box
            const uint JP2_CDEF = 0x63646566;

            while (true)
            {
                if (read(data, 0, 8) != 8) break;
                length = getIntBigEndian(data, 0) - 8;
                uint box = getUIntBigEndian(data, 4);

                if (length < 0) return false;

                //This is a box that contains boxes. We therefore
                //don't want to skip it, as it's the boxes inside 
                //we want.
                if (box == JP2_JP2H) continue;

                //This is the image header box. Contains basic image
                //information
                if (box == JP2_IHDR)
                {
                    if (length != 14 || read(data, 0, 14) != 14) return false;

                    //Yes, height comes first for some weird reason
                    img.Height = getIntBigEndian(data, 0);
                    img.Width = getIntBigEndian(data, 4);

                    //Number of components
                    int ncomps = GetUShortBigEndian(data, 8);
                    byte bpc = data[10];

                    //Checks the compression type.
                    if (data[11] != 7) return false;

                    //Unkonwn color space.
                    must_have_colorspace = data[12] == 0;

                    //Last byte is "Intellectual Property Rights"

                    //Fills out the bits per component array
                    bits_per_component = new byte[ncomps];
                    for (int c = 0; c < ncomps; c++)
                        bits_per_component[c] = bpc;

                    //When bpc is 255 we have to look for the
                    //bits per component box
                    have_image_header = true;
                    if (bpc != 255)
                    {
                        if (!must_have_colorspace && has_cdef)
                            break;
                    }
                    else
                        must_have_bpc_header = true;
                    continue;
                }

                //The induvidual number of bits per component
                if (box == JP2_BPCC)
                {
                    if (!have_image_header || length != bits_per_component.Length)
                        return false;
                    must_have_bpc_header = false;
                    if (read(bits_per_component) != bits_per_component.Length)
                        return false;

                    if (must_have_colorspace || !has_cdef) continue;
                    break;
                }

                //The colorspace
                if (box == JP2_COLR)
                {
                    if (length < 3 || read(data, 0, 3) != 3) return false;

                    var meth = data[0];
                    var precedence = data[1];
                    var approx = data[2];

                    if (meth == 1)
                    {
                        if (length != 7 || read(data, 0, 4) != 4) return false;
                        _current_image.Tags[(Tag.ID)262] = new Tag((Tag.ID)262, getIntBigEndian(data, 0));
                    }
                    else
                    {
                        // skips ICC
                        skip(length - 3);
                        continue;
                    }


                    must_have_colorspace = false;
                    if (!must_have_bpc_header && has_cdef) break;
                    continue;
                }

                //Channel definitions
                if (box == JP2_CDEF)
                {
                    if (length < 2 || read(data, 0, 2) != 2) return false;

                    int ncomps = GetUShortBigEndian(data, 0);
                    if (ncomps == 0) return false;

                    for (int i = 0; i < ncomps; ++i)
                    {
                        if (read(data, 0, 6) != 6) return false;

                        //int cn = GetUShortBigEndian(data, 0);
                        int typ = GetUShortBigEndian(data, 2);
                        //int asoc = GetUShortBigEndian(data, 2);
                        if (typ == 1 || typ == 2)
                            _current_image.Tags[Tag.ID.HasAlpha] = new Tag(Tag.ID.HasAlpha, true);
                    }

                    has_cdef = true;
                    if (!must_have_bpc_header && !must_have_colorspace)
                        break;
                }

                //Skipping unknown box
                skip(length);
            }

            if (!have_image_header || must_have_bpc_header) return false;

            //Calculates bits per pixel.
            for (int c = 0; c < bits_per_component.Length; c++)
                img.BitsPerPixel += (bits_per_component[c] & 0x7F) + 1;

            _numberOfImages = 1;
            _format = FORMAT.JP2;

            return true;
        }

        private bool checkJ2k()
        {
            //Only tested on a single J2K file.
            byte[] data = new byte[16];
            Info img = _current_image;

            const int J2K_MS_SOC = 0xff4f; //Start of codestream
            const int J2K_MS_SIZ = 0xff51; //Size of image and tile
            const int J2K_MS_COM = 0xff64; //Comment

            while (true)
            {
                if (read(data, 0, 2) != 2)
                    return false;

                int marker = GetUShortBigEndian(data, 0);

                if (marker == J2K_MS_SIZ)
                {
                    //First skips some uninteresting data
                    skip(4);

                    //Reads the size of the image
                    if (read(data, 0, 16) != 16) return false;
                    int x1 = getIntBigEndian(data, 0);
                    int y1 = getIntBigEndian(data, 4);
                    int x0 = getIntBigEndian(data, 8);
                    int y0 = getIntBigEndian(data, 12);

                    if (x1 < x0 || x0 < 0 || y1 < y0 || y0 < 0)
                        return false;

                    img.Width = x1 - x0;
                    img.Height = y1 - y0;

                    if (img.Width < 0 || img.Height < 0) return false;

                    //Skips some more uninteresting stuff.
                    skip(16);

                    //Number of components
                    if (read(data, 0, 2) != 2) return false;
                    int nComps = GetUShortBigEndian(data, 0);
                    if (nComps == 0) return false;

                    for (int c = 0; c < nComps; c++)
                    {
                        //Reads bpp, I hope
                        if (read(data, 0, 1) != 1) return false;
                        int bpp = (data[0] & 0x7f) + 1;
                        img.BitsPerPixel += bpp;
                        //Todo: Use Tags to describe BitsPerColor

                        //Skips uninteresting stuff
                        skip(2);
                    }

                    _numberOfImages = 1;
                    _format = FORMAT.J2K;
                    return true;
                }

                if (marker == J2K_MS_SOC)
                    continue;

                //There are a varity of more markers:
                //SOT (Start of Tile)
                //SOD (Start of Data)
                //EOC (End of Code)
                // ++
                //Of this I think only the "COM" marker
                //can slip in before SOC and SIZ
                //
                //One can find the size of most markers
                //by reading the ushort right after the
                //marker, but there are a good few 
                //exceptions so only supporting COM for 
                //now
                if (marker == J2K_MS_COM)
                {
                    //Reads the length and skips over it
                    if (read(data, 0, 2) != 2) return false;
                    skip(GetUShortBigEndian(data, 0));
                    continue;
                }

                return false;
            }
        }

        private bool checkJpeg()
        {
            byte[] data = new byte[12];
            Info img = _current_image;

            while (true)
            {
                if (read(data, 0, 4) != 4)
                {
                    return false;
                }
                int marker = GetUShortBigEndian(data, 0);
                int size = GetUShortBigEndian(data, 2);
                if ((marker & 0xff00) != 0xff00)
                {
                    return false; // not a valid marker
                }
                if (marker == 0xffe0)
                { // APPx 
                    if (size < 14)
                    {
                        // not an APPx header as we know it, skip
                        skip(size - 2);
                        continue;
                    }
                    if (read(data, 0, 12) != 12)
                    {
                        return false;
                    }
                    /*const*/
                    byte[] APP0_ID = { 0x4a, 0x46, 0x49, 0x46, 0x00 };
                    if (equals(APP0_ID, 0, data, 0, 5))
                    {
                        //System.out.println("data 7=" + data[7]);
                        if (data[7] == 1)
                        {
                            img.XResolution = GetUShortBigEndian(data, 8);
                            img.YResolution = GetUShortBigEndian(data, 10);
                        }
                        else
                            if (data[7] == 2)
                        {
                            int x = GetUShortBigEndian(data, 8);
                            int y = GetUShortBigEndian(data, 10);
                            img.XResolution = (int)(x * 2.54f);
                            img.YResolution = (int)(y * 2.54f);
                        }
                    }
                    skip(size - 14);
                }
                else
                    if (_collectComments && size > 2 && marker == 0xfffe)
                { // comment
                    size -= 2;
                    byte[] chars = new byte[size];
                    if (read(chars, 0, size) != size)
                        return false;

                    //Note: I don't know the character encoding
                    string comment = Encoding.ASCII.GetString(chars);
                    comment = comment.Trim();
                    img.AddComment(comment);
                }
                else
                        if (marker >= 0xffc0 && marker <= 0xffcf && marker != 0xffc4 && marker != 0xffc8)
                {
                    if (read(data, 0, 6) != 6)
                    {
                        return false;
                    }
                    _format = FORMAT.JPEG;
                    img.BitsPerPixel = (data[0] & 0xff) * (data[5] & 0xff);
                    img.NComponents = data[5];
                    img.Progressive = marker == 0xffc2 || marker == 0xffc6 ||
                        marker == 0xffca || marker == 0xffce;
                    img.Width = GetUShortBigEndian(data, 3);
                    img.Height = GetUShortBigEndian(data, 1);
                    _numberOfImages = 1;
                    return true;
                }
                else
                {
                    skip(size - 2);
                }
            }
        }

        private bool checkPcx()
        {
            byte[] a = new byte[64];
            if (read(a) != a.Length)
            {
                return false;
            }
            if (a[0] != 1)
            { // encoding, 1=RLE is only valid value
                return false;
            }
            // width / height
            int x1 = GetUShortLittleEndian(a, 2);
            int y1 = GetUShortLittleEndian(a, 4);
            int x2 = GetUShortLittleEndian(a, 6);
            int y2 = GetUShortLittleEndian(a, 8);
            if (x1 < 0 || x2 < x1 || y1 < 0 || y2 < y1)
            {
                return false;
            }
            Info img = _current_image;
            img.Width = x2 - x1 + 1;
            img.Height = y2 - y1 + 1;
            // color depth
            int bits = a[1];
            int planes = a[63];
            if (planes == 1 &&
                (bits == 1 || bits == 2 || bits == 4 || bits == 8))
            {
                // paletted
                img.BitsPerPixel = bits;
            }
            else
                if (planes == 3 && bits == 8)
            {
                // RGB truecolor
                img.BitsPerPixel = 24;
            }
            else
            {
                return false;
            }
            img.XResolution = GetUShortLittleEndian(a, 10);
            img.YResolution = GetUShortLittleEndian(a, 10);
            _format = FORMAT.PCX;
            _numberOfImages = 1;
            return true;
        }

        private bool checkPng()
        {
            /*const*/
            byte[] PNG_MAGIC = { 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a };
            byte[] a = new byte[27];
            if (read(a) != 27)
            {
                return false;
            }
            if (!equals(a, 0, PNG_MAGIC, 0, 6))
            {
                return false;
            }
            Info img = _current_image;
            _format = FORMAT.PNG;
            img.Width = getIntBigEndian(a, 14);
            img.Height = getIntBigEndian(a, 18);
            img.BitsPerPixel = a[22] & 0xff;
            int colorType = a[23] & 0xff;
            if (colorType == 2 || colorType == 6)
            {
                img.BitsPerPixel *= 3;
            }
            img.Progressive = (a[26] & 0xff) != 0;
            _numberOfImages = 1;
            return true;
        }

        /// <summary>
        /// Checks for PNM v7
        /// </summary>
        /// <remarks>
        /// v7 has a very different header, so I've out this into it's own function.
        /// Specs: https://netpbm.sourceforge.net/doc/pam.html
        /// 
        /// Weakness of checkPnm: 
        ///  -Can't collect comments after header statements.
        ///  -Ignores any extra tokens after header statements, comments or not.
        ///   (PdfImage.CreateFromPAMData is coded to fail if a non-comment comes
        ///    after a header statment, but I think this approach is OK. PNM files
        ///    typically don't have comments nor junk data.)
        /// 
        /// Strengths of checkPnm:
        ///  - Checks if bpp/depth makes sense with the color space
        ///  - Collects comments
        ///  - Detects more than one image (not tested)
        /// </remarks>
        private bool checkPnm()
        {
            int val;
            _format = FORMAT.PAM;
            string s;
            Info img = _current_image;
            var sb = new StringBuilder(16);
            int bpc = -1;
            int expected_ncomps = -1;
            int expected_bpc = -1;
            bool has_depth = false;

            while ((s = readLine(sb)) != null)
            {
                s = s.Trim();
                if (s == null || s.Length < 1)
                    continue;
                if (s[0] == '#')
                { // comment
                    if (_collectComments && s.Length > 1)
                        img.AddComment(s.Substring(1));
                    continue;
                }
                var vals = s.Split(' ');
                if (vals[0] == "WIDTH" && vals.Length >= 2 && int.TryParse(vals[1], out val))
                    img.Width = val;
                else if (vals[0] == "HEIGHT" && vals.Length >= 2 && int.TryParse(vals[1], out val))
                    img.Height = val;
                else if (vals[0] == "DEPTH" && vals.Length >= 2 && int.TryParse(vals[1], out val))
                {
                    has_depth = val > 1;
                    img.NComponents = val;
                }
                else if (vals[0] == "MAXVAL" && vals.Length >= 2 && int.TryParse(vals[1], out val))
                {
                    if (val > 65535 || val < 1)
                        break;
                    bpc = (int)Math.Log(val, 2) + 1;
                }
                else if (vals[0] == "TUPLTYPE" && vals.Length >= 2)
                {
                    bool has_alpha = false;
                    switch (vals[1])
                    {
                        case "BLACKANDWHITE":
                            expected_ncomps = 1;
                            expected_bpc = 1;
                            break;
                        case "GRAYSCALE":
                            expected_ncomps = 1;
                            break;
                        case "RGB":
                            expected_ncomps = 3;
                            break;
                        case "BLACKANDWHITE_ALPHA":
                            has_alpha = true;
                            goto case "BLACKANDWHITE";
                        case "GRAYSCALE_ALPHA":
                            has_alpha = true;
                            goto case "GRAYSCALE";
                        case "RGB_ALPHA":
                            has_alpha = true;
                            goto case "RGB";
                    }

                    if (has_alpha)
                    {
                        img.Tags[Tag.ID.HasAlpha] = new Tag(Tag.ID.HasAlpha, true);
                        expected_ncomps++;
                    }
                }
                else if (vals[0] == "ENDHDR" && vals.Length == 1)
                {
                    if (!has_depth ||
                        expected_bpc > 0 && expected_ncomps != img.NComponents ||
                        img.NComponents < 1 || bpc < 1)
                        break;

                    img.BitsPerPixel = img.NComponents * bpc;

                    if (img.Width > 0 && img.Height > 0)
                    {
                        long size = 
                            (long)(img.Width * img.Height) * 
                            ((bpc > 8) ? 2 : 1) *
                            (long) img.NComponents;

                        long bytes_left = (long) (_inn.Length - _inn.Position);

                        if (bytes_left < size)
                            break;
                        
                        //The +32 accounts for the minimum sized header of a P7 image
                        if (bytes_left > size + 32)
                        {
                            bpc = expected_ncomps = expected_bpc = -1;
                            has_depth = false;

                            _inn.Seek(size, SeekOrigin.Current);
                            //Check for P7
                            if (_inn.ReadByte() == 0x50 && _inn.ReadByte() == 0x37)
                            {
                                Debug.Assert(false, "Untested code");

                                //Stores the image info away
                                _numberOfImages++;
                                if (_images == null)
                                    _images = new List<Info>();
                                _images.Add(img);
                                img = new Info();
                                _current_image = img;
                                continue;
                            }
                        }

                        return true;
                    }

                    break;
                }
            }

            return false;
        }

        private bool checkPnm(int id)
        {
            if (id < 1 || id > 6)
            {
                return false;
            }
            /*const*/
            FORMAT[] PNM_FORMATS = { FORMAT.PBM, FORMAT.PGM, FORMAT.PPM };
            _format = PNM_FORMATS[(id - 1) % 3];
            bool hasPixelResolution = false;
            string s;
            Info img = _current_image;
            var sb = new StringBuilder();

            while ((s = readLine(sb)) != null)
            {
                s = s.Trim();
                if (s.Length < 1)
                    continue;

                if (s[0] == '#')
                { // comment
                    if (_collectComments && s.Length > 1)
                    {
                        img.AddComment(s.Substring(1));
                    }
                    continue;
                }
                if (!hasPixelResolution)
                { // split "343 966" into width=343, height=966
                    int spaceIndex = s.IndexOf(' ');
                    if (spaceIndex == -1)
                    {
                        return false;
                    }
                    string widthString = s.Substring(0, spaceIndex);
                    spaceIndex = s.LastIndexOf(' ');
                    if (spaceIndex == -1)
                    {
                        return false;
                    }
                    string heightString = s.Substring(spaceIndex + 1);
                    try
                    {
                        img.Width = int.Parse(widthString);
                        img.Height = int.Parse(heightString);
                    }
                    catch (FormatException)
                    {
                        return false;
                    }
                    if (img.Width < 1 || img.Height < 1)
                    {
                        return false;
                    }
                    if (_format == FORMAT.PBM)
                    {
                        img.BitsPerPixel = 1;
                        _numberOfImages = 1;
                        return true;
                    }
                    hasPixelResolution = true;
                }
                else
                {
                    int maxSample;
                    try
                    {
                        maxSample = int.Parse(s);
                    }
                    catch (FormatException)
                    {
                        return false;
                    }
                    if (maxSample < 0)
                    {
                        return false;
                    }
                    for (int i = 0; i < 25; i++)
                    {
                        if (maxSample < 1 << i + 1)
                        {
                            img.BitsPerPixel = i + 1;
                            if (_format == FORMAT.PPM)
                            {
                                img.BitsPerPixel *= 3;
                            }
                            _numberOfImages = 1;
                            return true;
                        }
                    }
                    return false;
                }
            }

            return false;
        }

        private bool checkPsd()
        {
            byte[] a = new byte[24];
            if (read(a) != a.Length)
            {
                return false;
            }
            /*const*/
            byte[] PSD_MAGIC = { 0x50, 0x53 };
            if (!equals(a, 0, PSD_MAGIC, 0, 2))
            {
                return false;
            }
            Info img = _current_image;
            _format = FORMAT.PSD;
            img.Width = getIntBigEndian(a, 16);
            img.Height = getIntBigEndian(a, 12);
            int channels = GetUShortBigEndian(a, 10);
            int depth = GetUShortBigEndian(a, 20);
            img.BitsPerPixel = channels * depth;

            if (img.Valid && img.BitsPerPixel <= 64)
            {
                _numberOfImages = 1;
                return true;
            }

            return false;
        }

        private bool checkRas()
        {
            byte[] a = new byte[14];
            if (read(a) != a.Length)
            {
                return false;
            }
            /*const*/
            byte[] RAS_MAGIC = { 0x6a, 0x95 };
            if (!equals(a, 0, RAS_MAGIC, 0, 2))
            {
                return false;
            }
            Info img = _current_image;
            _format = FORMAT.RAS;
            img.Width = getIntBigEndian(a, 2);
            img.Height = getIntBigEndian(a, 6);
            img.BitsPerPixel = getIntBigEndian(a, 10);
            if (img.Valid && img.BitsPerPixel <= 24)
            {
                _numberOfImages = 1;
                return true;
            }
            return false;
        }

        #endregion

        #region get methods


        /// <summary>
        /// Used for decompessing strips
        /// </summary>
        /// <param name="compressed_data">The compressed strip data</param>
        /// <param name="size">Size of the buffer</param>
        /// <param name="width">Numer of pixels on the row</param>
        /// <param name="height">Number of rows</param>
        /// <param name="target">Where to write the data</param>
        /// <param name="pos">Position in write array</param>
        /// <returns>True if decompression worked as intended</returns>
        public delegate bool Decompress(byte[] compressed_data, int size, int width, int height, byte[] target, int pos);

        /// <summary>
        /// Fetches the raw image data
        /// </summary>
        /// <returns>Only works for TIFF files smaller than 2GB</returns>
        public byte[] getRawData()
        {
            return getRawData((compressed_data, size, width, height, target, pos) =>
            {
                Buffer.BlockCopy(compressed_data, 0, target, pos, size);
                return true;
            }, true);
        }

        /// <summary>
        /// Fetches the raw image data.
        /// </summary>
        /// <remarks>Only works on TIFF files smaller than 2GB</remarks>
        public byte[] getRawData(Decompress func, bool ret_data)
        {
            if (Format != FORMAT.TIF || _images == null)
                return null;

            Info img = _current_image;

            //Fills out the size array
            byte[] buffer;
            byte[] num;
            uint[] stripbytesize = null;
            Tag StripByteCounts = null;
            StripByteCounts = img.Tags[Tag.ID.STRIPBYTECOUNT];
            stripbytesize = new uint[StripByteCounts.Count];


            int buffer_size = 0;

            //Reads in the strip byte counts
            _inn.Seek(StripByteCounts.UValue + _inn_origin, SeekOrigin.Begin);
            num = new byte[StripByteCounts.TagSize];

            for (int i = 0; i < StripByteCounts.Count; i++)
            {
                _inn.Read(num, 0, num.Length);
                var temp = num.Length == 4 ? readUInt(num, 0) : readUShort(num, 0);
                stripbytesize[i] = temp;
                buffer_size = Math.Max(buffer_size, (int)Math.Min(temp, int.MaxValue));
            }
            if (stripbytesize.Length == 1 && img.CompressedSize != 0)
                stripbytesize[0] = img.CompressedSize;

            int stride = (img.BitsPerPixel * img.Width + 7) / 8;
            switch (img.BitsPerSample)
            { //This may possibly only be valid for uncompressed images. 
                case 32:
                    var s = 4 - stride % 4;
                    if (s != 4)
                        stride += s;
                    break;
                case 16:
                    var ss = 2 - stride % 2;
                    if (ss != 2)
                        stride += ss;
                    break;
            }

            if (img.CompressedSize != 0)
                buffer_size = Math.Min((int)img.CompressedSize, buffer_size);
            buffer = new byte[buffer_size];

            //Reads in the strip offsets
            Tag StripOffset = img.Tags[Tag.ID.STRIPOFFSETS];
            uint[] stripoffsets = new uint[StripOffset.Count];
            if (!StripOffset.IsOffset)
                stripoffsets[0] = StripOffset.UValue;
            else
            {
                if (stripbytesize == null || stripbytesize.Length != stripoffsets.Length) return null;

                _inn.Seek(StripOffset.UValue + _inn_origin, SeekOrigin.Begin);
                num = new byte[StripOffset.TagSize];

                for (int i = 0; i < StripOffset.Count; i++)
                {
                    _inn.Read(num, 0, num.Length); //I'm thinking "readUShort" is pointless here as 16-bit offsets are unlikely
                    stripoffsets[i] = num.Length == 4 ? readUInt(num, 0) : readUShort(num, 0);
                }
            }

            int height = img.Height;
            int rows_per_strip = stripoffsets.Length > 1 ? img.RowsPerStrip : height;
            int bytes_per_strip = rows_per_strip * stride;
            byte[] data = ret_data ? new byte[stride * img.Height] : null;

            //Reads inn one strip at the time and decompress it
            for (int i = 0, write_pos = 0; i < stripoffsets.Length; i++)
            {
                _inn.Seek(stripoffsets[i] + _inn_origin, SeekOrigin.Begin);
                uint length = stripbytesize[i];
                if (_inn.Read(buffer, 0, (int)length) != length)
                    return null;

                func(buffer, (int)length, img.Width, height - Math.Max(0, height -= rows_per_strip), data, write_pos);
                write_pos += bytes_per_strip;
                //height -= rows_per_strip;
            }

            return data;
        }

        /// <summary>
        /// Returns the index'th comment retrieved from the File.
        /// </summary>
        /// <remarks>
        /// Return N/A if there's no comment.
        /// </remarks>
        /// <param name="index">index int index of comment to return</param>
        public string getComment(int index)
        {
            index += (int)Tag.ID.COMMENT;
            Tag t = null;
            if (_current_image.Tags.TryGetValue((Tag.ID)index, out t))
                return t.Comment;

            return Tag.NA;
        }

        /// <summary>
        /// When not using DetermineImageCount when opening TIFF files
        /// this function can be used to force the next TIFF image to render.
        /// </summary>
        /// <remarks>The next image will not be set aa the current image. That
        /// still has to be done by using the SelectImage function.</remarks>
        /// <returns>True if the operation sucseeded</returns>
        public bool DecodeNext()
        {
            if (DetermineImageCount || _format != FORMAT.TIF || _next_offset == 0)
                return false;

            return checkIFDs(_next_offset);
        }

        [Obsolete("Tif only")]
        public int getCompressionOptions()
        {
            if (_format != FORMAT.TIF || _images == null)
                return -1;

            const Tag.ID i = Tag.ID.T4OPTIONS;
            Tag t = null;
            if (_current_image.Tags.TryGetValue(i, out t))
                return t.Value;
            const Tag.ID i2 = Tag.ID.T6OPTIONS;
            if (_current_image.Tags.TryGetValue(i2, out t))
                return t.Value;

            //Assumes Fill Order 2.
            if (_current_image.Compression == COMPRESSION_SCHEME.CCITT_G3)
                return 0xF0;

            return 0;
        }
        [Obsolete("Tif only")]
        public bool getFillOrder()
        {
            const Tag.ID i = Tag.ID.FILLORDER;
            Tag t = null;
            return _current_image.Tags.TryGetValue(i, out t) ? t.BValue : false;
        }

        #endregion

        #region Read methods

        private static ushort GetUShortBigEndian(byte[] a, int offs)
        {
            return (ushort)((a[offs] & 0xff) << 8 | a[offs + 1] & 0xff);
        }

        private static ushort GetUShortLittleEndian(byte[] a, int offs)
        {
            return (ushort)(a[offs] & 0xff | (a[offs + 1] & 0xff) << 8);
        }

        /// <summary>
        /// Reads an integer and corrects for endianess
        /// </summary>
        /// <param name="a">The array to read from</param>
        /// <param name="offs">offset into the array</param>
        private int readInt(byte[] a, int offs)
        {
            return _bigEndian ? getIntBigEndian(a, offs) : getIntLittleEndian(a, offs);
        }
        private uint readUInt(byte[] a, int offs)
        {
            return _bigEndian ? getUIntBigEndian(a, offs) : getUIntLittleEndian(a, offs);
        }

        /// <summary>
        /// Reads an 16-bit integer and corrects for endianess
        /// </summary>
        /// <param name="a">The array to read from</param>
        /// <param name="offs">offset into the array</param>
        private ushort readUShort(byte[] a, int offs)
        {
            return _bigEndian ? GetUShortBigEndian(a, offs) : GetUShortLittleEndian(a, offs);
        }

        private static int getIntBigEndian(byte[] a, int offs)
        {
            return
                (a[offs] & 0xff) << 24 |
                (a[offs + 1] & 0xff) << 16 |
                (a[offs + 2] & 0xff) << 8 |
                a[offs + 3] & 0xff;
        }

        private static int getIntLittleEndian(byte[] a, int offs)
        {
            return
                (a[offs + 3] & 0xff) << 24 |
                (a[offs + 2] & 0xff) << 16 |
                (a[offs + 1] & 0xff) << 8 |
                a[offs] & 0xff;
        }
        private static uint getUIntBigEndian(byte[] a, int offs)
        {
            return
                (a[offs] & 0xffU) << 24 |
                (a[offs + 1] & 0xffU) << 16 |
                (a[offs + 2] & 0xffU) << 8 |
                a[offs + 3] & 0xffU;
        }
        private static uint getUIntLittleEndian(byte[] a, int offs)
        {
            return
                (a[offs + 3] & 0xffU) << 24 |
                (a[offs + 2] & 0xffU) << 16 |
                (a[offs + 1] & 0xffU) << 8 |
                a[offs] & 0xffU;
        }

        private int read()
        {
            return _inn.ReadByte();
        }

        private int read(byte[] a)
        {
            return read(a, 0, a.Length);
        }

        private int read(byte[] buffer, int offset, int num)
        {
            int nRead = offset;
            for (int nToRead = num; nToRead > 0;)
            {
                int read = _inn.Read(buffer, nRead, nToRead);
                if (read == 0) break;

                nRead += read;
                nToRead -= read;
            }

            return nRead - offset;
        }

        private string readLine(StringBuilder sb)
        {
            sb.Length = 0;
            while(true)
            {
                int value = read();
                if (value == -1)
                    return null;
                if (value == 10)
                    return sb.ToString();
                sb.Append((char)value);
            }
        }

        #endregion

        #region Properties

        /// <summary>
        /// If J2P images has alpha embeded in the data
        /// </summary>
        public bool HasAlpha { get { return _current_image.HasAlpha; } }

        /// <summary>
        /// Current image's compression scheme.
        /// </summary>
        public COMPRESSION_SCHEME CompressionScheme { get { return _current_image.Compression; } }

        /// <summary>
        /// Specify whether textual comments are supposed to be extracted from input.
        /// Default is <code>false</code>.
        /// </summary>
        /// <remarks>
        /// If enabled, comments will be added to an internal list.
        /// </remarks>
        public bool CollectComments
        {
            get { return _collectComments; }
            set
            {
                _collectComments = value;
                _valid = recheck();
            }
        }

        /// <summary>
        /// If the container is laid out in big endian format.
        /// </summary>
        public bool BigEndian { get { return _bigEndian; } }

        /// <summary>
        /// returns the number of comments retrieved from the input image stream
        /// Set CollectComments true before using this property
        /// </summary>
        public int NumberOfComments { get { return _current_image.CommentCount; } }

        /// <summary>
        /// Specify whether the number of images in a File is to be
        /// determined - default is <code>false</code>.
        /// </summary>
        /// <remarks>
        /// This is a special option because some File formats require running over
        /// the entire File to find out the number of images, a rather time-consuming
        /// task.
        /// 
        /// Not all File formats support more than one image.
        /// </remarks>
        public bool DetermineImageCount
        {
            get { return _determineNumberOfImages; }
            set
            {
                _determineNumberOfImages = true;
                _valid = recheck();
            }
        }

        public bool CheckIfTargaFormat
        {
            get { return _checkIfTarga; }
            set
            {
                _checkIfTarga = value;
                _valid = recheck();
            }
        }

#if CELESTE
        public bool CheckIfCelesteFormat
        {
            get { return _checkIfCeleste; }
            set
            {
                _checkIfCeleste = value;
                _valid = recheck();
            }
        }
#endif

        /// <summary>
        /// If there's more images in the File stream.
        /// </summary>
        /// <remarks>Only usefull when DetermineImageCount is set to false
        /// while working with TIFF images.</remarks>
        public bool HasMoreImages
        {
            get
            {
                if (_format != FORMAT.TIF)
                    return false;

                return _next_offset != 0;
            }
        }

        /// <summary>
        /// Bits per pixel for the current image.
        /// </summary>
        public int BitsPerPixel { get { return _current_image.BitsPerPixel; } }

        /// <summary>
        /// How many bits are in each color.
        /// </summary>
        /// <remarks>Colors are sepperated by "-"</remarks>
        public string BitsPerColor { get { return _current_image.BitsPerColor; } }

        /// <summary>
        /// How many bits are in a component
        /// </summary>
        public int BitsPerComponent { get { return _current_image.BitsPerSample; } }

        /// <summary>
        /// Returns the number of images in the examined File.
        /// Set DetermineImageCount true to use this property.
        /// </summary>
        public int ImageCount { get { return _numberOfImages; } }

        /// <summary>
        /// All collected data about the current image.
        /// </summary>
        public Info Meta { get { return _current_image; } }

        /// <summary>
        /// Set the input stream. Must support seek.
        /// </summary>
        public Stream Stream
        {
            set
            {
                if (value == null)
                {
                    _images = null;
                    _valid = false;
                    _next_offset = 0;
                    _numberOfImages = 0;
                    _format = FORMAT.UNKNOWN;

                    //Resets the stream, but does not close it.
                    if (_inn != null)
                    {
                        _inn.Seek(_inn_origin, SeekOrigin.Begin);
                        _inn = null;
                    }
                    return;
                }

                if (!value.CanSeek || !value.CanRead)
                    throw new ArgumentException("Stream does not support seek");

                _inn = value;
                _images = null;
                _inn_origin = _inn.Position;
                _valid = check();
            }
            get { return _inn; }
        }

        ///<summary>
        ///The format of the File containing the image
        ///</summary>
        public FORMAT Format
        {
            get { return _format; }
        }

        /// <summary>
        /// The color space of the image, if known. 
        /// (Only meaningful for JPX images. Though TIFF
        ///  also use tag 262 for colorpspace info)
        /// </summary>
        public COLORSPACE ColorSpace
        {
            get
            {
                Tag tag;
                if (_current_image.Tags.TryGetValue((Tag.ID)262, out tag))
                    return (COLORSPACE)tag.Value;
                return COLORSPACE.UNKNOWN;
            }
        }

        /**
         * Typical extension name of the type of File containing the image
         * Use {@link #getFormat()} to get a unique number.
         * @return File format name
         */
        public string FormatExtension
        {
            get { return FORMAT_EXTENSION[(int)_format]; }
        }

        ///<summary> 
        /// The MIME type of the container format.
        /// @return MIME type, e.g. image/jpeg
        ///</summary>
        public string MimeType
        {
            get
            {
                if (_format == FORMAT.JPEG && _current_image.Progressive)
                {
                    return "image/pjpeg";
                }
                return MIME_TYPE_STRINGS[(int)_format];
            }
        }

        /// <summary>
        /// Width of the currently selected image in pixels
        /// </summary>
        public int Width { get { return _current_image.Width; } }

        /// <summary>
        /// Height of the currently selected image in pixels
        /// </summary>
        public int Height { get { return _current_image.Height; } }

        /// <summary>
        /// The physical width of this image (usualy dpi).
        /// or -1 if no value could be found.
        /// </summary>
        public int PhysicalWidth { get { return _current_image.XResolution; } }

        /// <summary>
        /// The physical height of this image (usualy dpi).
        /// -1 on failure.
        /// </summary>
        public int PhysicalHeight { get { return _current_image.YResolution; } }

        #endregion

        #region other ImageInfo related methods

        private static bool equals(byte[] a1, int offs1, byte[] a2, int offs2, int num)
        {
            while (num-- > 0)
            {
                if (a1[offs1++] != a2[offs2++])
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Returns whether the image is stored in a progressive 
        /// (also called: interlaced) way.
        /// 
        /// True for progressive/interlaced, false otherwise
        /// </summary>
        public bool Progressive { get { return _current_image.Progressive; } }

        private void skip(int num)
        {
            while (num > 0)
            {
                long result = -1;
                if (_inn != null)
                    result = _inn.ReadByte();
                num--;
                if (result == -1)
                    throw new IOException("Premature end of input.");
            }
        }

        #endregion
    }
}
